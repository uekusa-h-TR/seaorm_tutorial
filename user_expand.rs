pub mod user {
    //! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.1
    use sea_orm::entity::prelude::*;
    #[sea_orm(table_name = "user")]
    pub struct Model {
        #[sea_orm(primary_key)]
        pub id: i32,
        #[sea_orm(unique)]
        pub pid: Uuid,
        pub name: String,
        #[sea_orm(unique)]
        pub email: String,
        pub password: String,
        pub created_at: DateTimeWithTimeZone,
        pub updated_at: DateTimeWithTimeZone,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Model {
        #[inline]
        fn clone(&self) -> Model {
            Model {
                id: ::core::clone::Clone::clone(&self.id),
                pid: ::core::clone::Clone::clone(&self.pid),
                name: ::core::clone::Clone::clone(&self.name),
                email: ::core::clone::Clone::clone(&self.email),
                password: ::core::clone::Clone::clone(&self.password),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Model {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "pid",
                "name",
                "email",
                "password",
                "created_at",
                "updated_at",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.pid,
                &self.name,
                &self.email,
                &self.password,
                &self.created_at,
                &&self.updated_at,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Model", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Model {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Model {
        #[inline]
        fn eq(&self, other: &Model) -> bool {
            self.id == other.id && self.pid == other.pid && self.name == other.name
                && self.email == other.email && self.password == other.password
                && self.created_at == other.created_at
                && self.updated_at == other.updated_at
        }
    }
    /// Generated by sea-orm-macros
    pub enum Column {
        /// Generated by sea-orm-macros
        Id,
        /// Generated by sea-orm-macros
        Pid,
        /// Generated by sea-orm-macros
        Name,
        /// Generated by sea-orm-macros
        Email,
        /// Generated by sea-orm-macros
        Password,
        /// Generated by sea-orm-macros
        CreatedAt,
        /// Generated by sea-orm-macros
        UpdatedAt,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Column {}
    #[automatically_derived]
    impl ::core::clone::Clone for Column {
        #[inline]
        fn clone(&self) -> Column {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Column {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Column::Id => "Id",
                    Column::Pid => "Pid",
                    Column::Name => "Name",
                    Column::Email => "Email",
                    Column::Password => "Password",
                    Column::CreatedAt => "CreatedAt",
                    Column::UpdatedAt => "UpdatedAt",
                },
            )
        }
    }
    ///An iterator over the variants of [Column]
    #[allow(missing_copy_implementations)]
    pub struct ColumnIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for ColumnIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("ColumnIter").field("len", &self.len()).finish()
        }
    }
    impl ColumnIter {
        fn get(&self, idx: usize) -> ::core::option::Option<Column> {
            match idx {
                0usize => ::core::option::Option::Some(Column::Id),
                1usize => ::core::option::Option::Some(Column::Pid),
                2usize => ::core::option::Option::Some(Column::Name),
                3usize => ::core::option::Option::Some(Column::Email),
                4usize => ::core::option::Option::Some(Column::Password),
                5usize => ::core::option::Option::Some(Column::CreatedAt),
                6usize => ::core::option::Option::Some(Column::UpdatedAt),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Column {
        type Iterator = ColumnIter;
        fn iter() -> ColumnIter {
            ColumnIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for ColumnIter {
        type Item = Column;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 7usize {
                0
            } else {
                7usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 7usize {
                self.idx = 7usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                ColumnIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for ColumnIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for ColumnIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 7usize {
                self.back_idx = 7usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                ColumnIter::get(self, 7usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for ColumnIter {}
    impl Clone for ColumnIter {
        fn clone(&self) -> ColumnIter {
            ColumnIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl Column {
        fn default_as_str(&self) -> &str {
            match self {
                Self::Id => "id",
                Self::Pid => "pid",
                Self::Name => "name",
                Self::Email => "email",
                Self::Password => "password",
                Self::CreatedAt => "created_at",
                Self::UpdatedAt => "updated_at",
            }
        }
    }
    #[automatically_derived]
    impl std::str::FromStr for Column {
        type Err = sea_orm::ColumnFromStrErr;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "id" | "id" => Ok(Column::Id),
                "pid" | "pid" => Ok(Column::Pid),
                "name" | "name" => Ok(Column::Name),
                "email" | "email" => Ok(Column::Email),
                "password" | "password" => Ok(Column::Password),
                "created_at" | "createdAt" => Ok(Column::CreatedAt),
                "updated_at" | "updatedAt" => Ok(Column::UpdatedAt),
                _ => Err(sea_orm::ColumnFromStrErr(s.to_owned())),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for Column {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Column {
        fn as_str(&self) -> &str {
            self.default_as_str()
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::ColumnTrait for Column {
        type EntityName = Entity;
        fn def(&self) -> sea_orm::prelude::ColumnDef {
            match self {
                Self::Id => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::Integer,
                    )
                }
                Self::Pid => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::Uuid,
                        )
                        .unique()
                }
                Self::Name => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::string(None),
                    )
                }
                Self::Email => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                            sea_orm::prelude::ColumnType::string(None),
                        )
                        .unique()
                }
                Self::Password => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::string(None),
                    )
                }
                Self::CreatedAt => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::TimestampWithTimeZone,
                    )
                }
                Self::UpdatedAt => {
                    sea_orm::prelude::ColumnTypeTrait::def(
                        sea_orm::prelude::ColumnType::TimestampWithTimeZone,
                    )
                }
            }
        }
        fn enum_type_name(&self) -> Option<&'static str> {
            match self {
                Self::Id => <i32 as sea_orm::sea_query::ValueType>::enum_type_name(),
                Self::Pid => <Uuid as sea_orm::sea_query::ValueType>::enum_type_name(),
                Self::Name => <String as sea_orm::sea_query::ValueType>::enum_type_name(),
                Self::Email => {
                    <String as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::Password => {
                    <String as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::CreatedAt => {
                    <DateTimeWithTimeZone as sea_orm::sea_query::ValueType>::enum_type_name()
                }
                Self::UpdatedAt => {
                    <DateTimeWithTimeZone as sea_orm::sea_query::ValueType>::enum_type_name()
                }
            }
        }
        fn select_as(
            &self,
            expr: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::select_enum_as(self, expr),
            }
        }
        fn save_as(
            &self,
            val: sea_orm::sea_query::Expr,
        ) -> sea_orm::sea_query::SimpleExpr {
            match self {
                _ => sea_orm::prelude::ColumnTrait::save_enum_as(self, val),
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct Entity;
    #[automatically_derived]
    impl ::core::marker::Copy for Entity {}
    #[automatically_derived]
    impl ::core::clone::Clone for Entity {
        #[inline]
        fn clone(&self) -> Entity {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Entity {
        #[inline]
        fn default() -> Entity {
            Entity {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Entity {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Entity")
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::EntityTrait for Entity {
        type Model = Model;
        type ActiveModel = ActiveModel;
        type Column = Column;
        type PrimaryKey = PrimaryKey;
        type Relation = Relation;
    }
    #[automatically_derived]
    impl sea_orm::Iden for Entity {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for Entity {
        fn as_str(&self) -> &str {
            <Self as sea_orm::EntityName>::table_name(self)
        }
    }
    #[automatically_derived]
    impl sea_orm::prelude::EntityName for Entity {
        fn schema_name(&self) -> Option<&str> {
            None
        }
        fn table_name(&self) -> &str {
            "user"
        }
        fn comment(&self) -> Option<&str> {
            None
        }
    }
    /// Generated by sea-orm-macros
    pub enum PrimaryKey {
        /// Generated by sea-orm-macros
        Id,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for PrimaryKey {}
    #[automatically_derived]
    impl ::core::clone::Clone for PrimaryKey {
        #[inline]
        fn clone(&self) -> PrimaryKey {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PrimaryKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Id")
        }
    }
    ///An iterator over the variants of [PrimaryKey]
    #[allow(missing_copy_implementations)]
    pub struct PrimaryKeyIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for PrimaryKeyIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("PrimaryKeyIter").field("len", &self.len()).finish()
        }
    }
    impl PrimaryKeyIter {
        fn get(&self, idx: usize) -> ::core::option::Option<PrimaryKey> {
            match idx {
                0usize => ::core::option::Option::Some(PrimaryKey::Id),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for PrimaryKey {
        type Iterator = PrimaryKeyIter;
        fn iter() -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for PrimaryKeyIter {
        type Item = PrimaryKey;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                PrimaryKeyIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for PrimaryKeyIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for PrimaryKeyIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                PrimaryKeyIter::get(self, 1usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for PrimaryKeyIter {}
    impl Clone for PrimaryKeyIter {
        fn clone(&self) -> PrimaryKeyIter {
            PrimaryKeyIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::Iden for PrimaryKey {
        fn unquoted(&self, s: &mut dyn std::fmt::Write) {
            s.write_fmt(format_args!("{0}", sea_orm::IdenStatic::as_str(self))).unwrap();
        }
    }
    #[automatically_derived]
    impl sea_orm::IdenStatic for PrimaryKey {
        fn as_str(&self) -> &str {
            match self {
                Self::Id => "id",
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::PrimaryKeyToColumn for PrimaryKey {
        type Column = Column;
        fn into_column(self) -> Self::Column {
            match self {
                Self::Id => Self::Column::Id,
            }
        }
        fn from_column(col: Self::Column) -> Option<Self> {
            match col {
                Self::Column::Id => Some(Self::Id),
                _ => None,
            }
        }
    }
    #[automatically_derived]
    impl PrimaryKeyTrait for PrimaryKey {
        type ValueType = i32;
        fn auto_increment() -> bool {
            true
        }
    }
    #[automatically_derived]
    impl sea_orm::FromQueryResult for Model {
        fn from_query_result(
            row: &sea_orm::QueryResult,
            pre: &str,
        ) -> std::result::Result<Self, sea_orm::DbErr> {
            Ok(Self {
                id: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Id,
                            )
                            .into(),
                    )?,
                pid: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Pid,
                            )
                            .into(),
                    )?,
                name: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Name,
                            )
                            .into(),
                    )?,
                email: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Email,
                            )
                            .into(),
                    )?,
                password: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::Password,
                            )
                            .into(),
                    )?,
                created_at: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::CreatedAt,
                            )
                            .into(),
                    )?,
                updated_at: row
                    .try_get(
                        pre,
                        sea_orm::IdenStatic::as_str(
                                &<<Self as sea_orm::ModelTrait>::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedAt,
                            )
                            .into(),
                    )?,
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::ModelTrait for Model {
        type Entity = Entity;
        fn get(
            &self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
        ) -> sea_orm::Value {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                    self.id.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Pid => {
                    self.pid.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                    self.name.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Email => {
                    self.email.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Password => {
                    self.password.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedAt => {
                    self.created_at.clone().into()
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.clone().into()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    );
                }
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::entity::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Id => {
                    self.id = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Pid => {
                    self.pid = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Name => {
                    self.name = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Email => {
                    self.email = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::Password => {
                    self.password = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::CreatedAt => {
                    self.created_at = v.unwrap();
                }
                <Self::Entity as sea_orm::entity::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at = v.unwrap();
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("field does not exist on Model"),
                    );
                }
            }
        }
    }
    /// Generated by sea-orm-macros
    pub struct ActiveModel {
        /// Generated by sea-orm-macros
        pub id: sea_orm::ActiveValue<i32>,
        /// Generated by sea-orm-macros
        pub pid: sea_orm::ActiveValue<Uuid>,
        /// Generated by sea-orm-macros
        pub name: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub email: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub password: sea_orm::ActiveValue<String>,
        /// Generated by sea-orm-macros
        pub created_at: sea_orm::ActiveValue<DateTimeWithTimeZone>,
        /// Generated by sea-orm-macros
        pub updated_at: sea_orm::ActiveValue<DateTimeWithTimeZone>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ActiveModel {
        #[inline]
        fn clone(&self) -> ActiveModel {
            ActiveModel {
                id: ::core::clone::Clone::clone(&self.id),
                pid: ::core::clone::Clone::clone(&self.pid),
                name: ::core::clone::Clone::clone(&self.name),
                email: ::core::clone::Clone::clone(&self.email),
                password: ::core::clone::Clone::clone(&self.password),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ActiveModel {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "pid",
                "name",
                "email",
                "password",
                "created_at",
                "updated_at",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.pid,
                &self.name,
                &self.email,
                &self.password,
                &self.created_at,
                &&self.updated_at,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ActiveModel",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ActiveModel {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ActiveModel {
        #[inline]
        fn eq(&self, other: &ActiveModel) -> bool {
            self.id == other.id && self.pid == other.pid && self.name == other.name
                && self.email == other.email && self.password == other.password
                && self.created_at == other.created_at
                && self.updated_at == other.updated_at
        }
    }
    #[automatically_derived]
    impl std::default::Default for ActiveModel {
        fn default() -> Self {
            <Self as sea_orm::ActiveModelBehavior>::new()
        }
    }
    #[automatically_derived]
    impl std::convert::From<Model> for ActiveModel {
        fn from(m: Model) -> Self {
            Self {
                id: sea_orm::ActiveValue::unchanged(m.id),
                pid: sea_orm::ActiveValue::unchanged(m.pid),
                name: sea_orm::ActiveValue::unchanged(m.name),
                email: sea_orm::ActiveValue::unchanged(m.email),
                password: sea_orm::ActiveValue::unchanged(m.password),
                created_at: sea_orm::ActiveValue::unchanged(m.created_at),
                updated_at: sea_orm::ActiveValue::unchanged(m.updated_at),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::IntoActiveModel<ActiveModel> for Model {
        fn into_active_model(self) -> ActiveModel {
            self.into()
        }
    }
    #[automatically_derived]
    impl sea_orm::ActiveModelTrait for ActiveModel {
        type Entity = Entity;
        fn take(
            &mut self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.id);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Pid => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.pid);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.name);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Email => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.email);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.password);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.created_at);
                    value.into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    let mut value = sea_orm::ActiveValue::not_set();
                    std::mem::swap(&mut value, &mut self.updated_at);
                    value.into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn get(
            &self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
        ) -> sea_orm::ActiveValue<sea_orm::Value> {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Pid => {
                    self.pid.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                    self.name.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Email => {
                    self.email.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                    self.password.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at.clone().into_wrapped_value()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.clone().into_wrapped_value()
                }
                _ => sea_orm::ActiveValue::not_set(),
            }
        }
        fn set(
            &mut self,
            c: <Self::Entity as sea_orm::EntityTrait>::Column,
            v: sea_orm::Value,
        ) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Pid => {
                    self.pid = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                    self.name = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Email => {
                    self.email = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                    self.password = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at = sea_orm::ActiveValue::set(v.unwrap());
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at = sea_orm::ActiveValue::set(v.unwrap());
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
        fn not_set(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Pid => {
                    self.pid = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                    self.name = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Email => {
                    self.email = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                    self.password = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at = sea_orm::ActiveValue::not_set();
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at = sea_orm::ActiveValue::not_set();
                }
                _ => {}
            }
        }
        fn is_not_set(&self, c: <Self::Entity as sea_orm::EntityTrait>::Column) -> bool {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => {
                    self.id.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Pid => {
                    self.pid.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Name => {
                    self.name.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Email => {
                    self.email.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                    self.password.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at.is_not_set()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.is_not_set()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
        fn default() -> Self {
            Self {
                id: sea_orm::ActiveValue::not_set(),
                pid: sea_orm::ActiveValue::not_set(),
                name: sea_orm::ActiveValue::not_set(),
                email: sea_orm::ActiveValue::not_set(),
                password: sea_orm::ActiveValue::not_set(),
                created_at: sea_orm::ActiveValue::not_set(),
                updated_at: sea_orm::ActiveValue::not_set(),
            }
        }
        fn reset(&mut self, c: <Self::Entity as sea_orm::EntityTrait>::Column) {
            match c {
                <Self::Entity as sea_orm::EntityTrait>::Column::Id => self.id.reset(),
                <Self::Entity as sea_orm::EntityTrait>::Column::Pid => self.pid.reset(),
                <Self::Entity as sea_orm::EntityTrait>::Column::Name => self.name.reset(),
                <Self::Entity as sea_orm::EntityTrait>::Column::Email => {
                    self.email.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::Password => {
                    self.password.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::CreatedAt => {
                    self.created_at.reset()
                }
                <Self::Entity as sea_orm::EntityTrait>::Column::UpdatedAt => {
                    self.updated_at.reset()
                }
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("This ActiveModel does not have this field"),
                    );
                }
            }
        }
    }
    #[automatically_derived]
    impl std::convert::TryFrom<ActiveModel> for Model {
        type Error = sea_orm::DbErr;
        fn try_from(a: ActiveModel) -> Result<Self, sea_orm::DbErr> {
            if match a.id {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("id".to_owned()));
            }
            if match a.pid {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("pid".to_owned()));
            }
            if match a.name {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("name".to_owned()));
            }
            if match a.email {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("email".to_owned()));
            }
            if match a.password {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("password".to_owned()));
            }
            if match a.created_at {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("created_at".to_owned()));
            }
            if match a.updated_at {
                sea_orm::ActiveValue::NotSet => true,
                _ => false,
            } {
                return Err(sea_orm::DbErr::AttrNotSet("updated_at".to_owned()));
            }
            Ok(Self {
                id: a.id.into_value().unwrap().unwrap(),
                pid: a.pid.into_value().unwrap().unwrap(),
                name: a.name.into_value().unwrap().unwrap(),
                email: a.email.into_value().unwrap().unwrap(),
                password: a.password.into_value().unwrap().unwrap(),
                created_at: a.created_at.into_value().unwrap().unwrap(),
                updated_at: a.updated_at.into_value().unwrap().unwrap(),
            })
        }
    }
    #[automatically_derived]
    impl sea_orm::TryIntoModel<Model> for ActiveModel {
        fn try_into_model(self) -> Result<Model, sea_orm::DbErr> {
            self.try_into()
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Model {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<i32>;
            let _: ::core::cmp::AssertParamIsEq<Uuid>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<DateTimeWithTimeZone>;
        }
    }
    pub enum Relation {
        #[sea_orm(has_one = "super::todo::Entity")]
        Todo,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Relation {}
    #[automatically_derived]
    impl ::core::clone::Clone for Relation {
        #[inline]
        fn clone(&self) -> Relation {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Relation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Todo")
        }
    }
    ///An iterator over the variants of [Relation]
    #[allow(missing_copy_implementations)]
    pub struct RelationIter {
        idx: usize,
        back_idx: usize,
        marker: ::core::marker::PhantomData<()>,
    }
    impl ::core::fmt::Debug for RelationIter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_struct("RelationIter").field("len", &self.len()).finish()
        }
    }
    impl RelationIter {
        fn get(&self, idx: usize) -> ::core::option::Option<Relation> {
            match idx {
                0usize => ::core::option::Option::Some(Relation::Todo),
                _ => ::core::option::Option::None,
            }
        }
    }
    impl sea_orm::strum::IntoEnumIterator for Relation {
        type Iterator = RelationIter;
        fn iter() -> RelationIter {
            RelationIter {
                idx: 0,
                back_idx: 0,
                marker: ::core::marker::PhantomData,
            }
        }
    }
    impl Iterator for RelationIter {
        type Item = Relation;
        fn next(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            self.nth(0)
        }
        fn size_hint(&self) -> (usize, ::core::option::Option<usize>) {
            let t = if self.idx + self.back_idx >= 1usize {
                0
            } else {
                1usize - self.idx - self.back_idx
            };
            (t, Some(t))
        }
        fn nth(&mut self, n: usize) -> ::core::option::Option<<Self as Iterator>::Item> {
            let idx = self.idx + n + 1;
            if idx + self.back_idx > 1usize {
                self.idx = 1usize;
                ::core::option::Option::None
            } else {
                self.idx = idx;
                RelationIter::get(self, idx - 1)
            }
        }
    }
    impl ExactSizeIterator for RelationIter {
        fn len(&self) -> usize {
            self.size_hint().0
        }
    }
    impl DoubleEndedIterator for RelationIter {
        fn next_back(&mut self) -> ::core::option::Option<<Self as Iterator>::Item> {
            let back_idx = self.back_idx + 1;
            if self.idx + back_idx > 1usize {
                self.back_idx = 1usize;
                ::core::option::Option::None
            } else {
                self.back_idx = back_idx;
                RelationIter::get(self, 1usize - self.back_idx)
            }
        }
    }
    impl ::core::iter::FusedIterator for RelationIter {}
    impl Clone for RelationIter {
        fn clone(&self) -> RelationIter {
            RelationIter {
                idx: self.idx,
                back_idx: self.back_idx,
                marker: self.marker.clone(),
            }
        }
    }
    #[automatically_derived]
    impl sea_orm::entity::RelationTrait for Relation {
        fn def(&self) -> sea_orm::entity::RelationDef {
            match self {
                Self::Todo => Entity::has_one(super::todo::Entity).into(),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("No RelationDef for Relation"),
                    );
                }
            }
        }
    }
    impl Related<super::todo::Entity> for Entity {
        fn to() -> RelationDef {
            Relation::Todo.def()
        }
    }
    impl ActiveModelBehavior for ActiveModel {}
}
